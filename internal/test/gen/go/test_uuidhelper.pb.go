// Code generated by protoc-gen-uuidhelper-go. DO NOT EDIT.
// Versions:
// - protoc-gen-uuidhelper-go v0.2.2-dev.11+dirty
// - protoc v5.29.3
// source: test.proto

package gen

import "github.com/google/uuid"

func (m *Player) GetInternalUUID() uuid.UUID {
	return uuid.Must(uuid.FromBytes(m.GetInternalUuid()))
}

func (m *Player) SetInternalUUID(u uuid.UUID) {
	m.InternalUuid = u[:]
}

func (m *Player) GetSessionUUID() uuid.UUID {
	return uuid.Must(uuid.FromBytes(m.GetSessionUuid()))
}

func (m *Player) SetSessionUUID(u uuid.UUID) {
	m.SessionUuid = u[:]
}

func (m *Player) GetGameUUIDs() []uuid.UUID {
	uuids := m.GetGameUuids()
	if len(uuids) == 0 {
		return nil
	}
	uuidsSlice := make([]uuid.UUID, len(uuids))
	for i, uid := range uuids {
		if len(uid) != 16 {
			return nil
		}
		uuidsSlice[i] = uuid.Must(uuid.FromBytes(uid))
	}
	return uuidsSlice
}

func (m *Player) SetGameUUIDs(u []uuid.UUID) {
	if len(u) == 0 {
		m.GameUuids = nil
		return
	}
	uuids := make([][]byte, len(u))
	for i, uid := range u {
		uuids[i] = uid[:]
	}
	m.GameUuids = uuids
}

func (m *Player) AddGameUUIDs(u ...uuid.UUID) {
	if m.GameUuids == nil {
		m.GameUuids = make([][]byte, 0, len(u))
	}
	for _, id := range u {
		m.GameUuids = append(m.GameUuids, id[:])
	}
}

func (m *Player) GetV1UUID() uuid.UUID {
	if bytes := m.GetV1Uuid(); bytes == nil {
		return uuid.Nil
	} else {
		return uuid.Must(uuid.FromBytes(bytes))
	}
}

func (m *Player) SetV1UUID(u uuid.UUID) {
	m.VersionedUuid = &Player_V1Uuid{V1Uuid: u[:]}
}

func (m *Player) GetV2UUID() uuid.UUID {
	if bytes := m.GetV2Uuid(); bytes == nil {
		return uuid.Nil
	} else {
		return uuid.Must(uuid.FromBytes(bytes))
	}
}

func (m *Player) SetV2UUID(u uuid.UUID) {
	m.VersionedUuid = &Player_V2Uuid{V2Uuid: u[:]}
}

func (m *Player_NestedMsg) GetNestedUUID() uuid.UUID {
	return uuid.Must(uuid.FromBytes(m.GetNestedUuid()))
}

func (m *Player_NestedMsg) SetNestedUUID(u uuid.UUID) {
	m.NestedUuid = u[:]
}

func (m *Player) GetOptUUID() uuid.UUID {
	if bytes := m.GetOptUuid(); bytes == nil {
		return uuid.Nil
	} else {
		return uuid.Must(uuid.FromBytes(bytes))
	}
}

func (m *Player) SetOptUUID(u uuid.UUID) {
	m.OptUuid = u[:]
}

func (m *Player) GetMapInt32UuidUUID() map[int32]uuid.UUID {
	if m.MapInt32Uuid == nil {
		return nil
	}
	uuids := make(map[int32]uuid.UUID, len(m.MapInt32Uuid))
	for k, v := range m.MapInt32Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapInt32UuidUUID(u map[int32]uuid.UUID) {
	if len(u) == 0 {
		m.MapInt32Uuid = nil
		return
	}
	protoMap := make(map[int32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapInt32Uuid = protoMap
}

func (m *Player) GetMapInt64UuidUUID() map[int64]uuid.UUID {
	if m.MapInt64Uuid == nil {
		return nil
	}
	uuids := make(map[int64]uuid.UUID, len(m.MapInt64Uuid))
	for k, v := range m.MapInt64Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapInt64UuidUUID(u map[int64]uuid.UUID) {
	if len(u) == 0 {
		m.MapInt64Uuid = nil
		return
	}
	protoMap := make(map[int64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapInt64Uuid = protoMap
}

func (m *Player) GetMapUint32UuidUUID() map[uint32]uuid.UUID {
	if m.MapUint32Uuid == nil {
		return nil
	}
	uuids := make(map[uint32]uuid.UUID, len(m.MapUint32Uuid))
	for k, v := range m.MapUint32Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapUint32UuidUUID(u map[uint32]uuid.UUID) {
	if len(u) == 0 {
		m.MapUint32Uuid = nil
		return
	}
	protoMap := make(map[uint32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapUint32Uuid = protoMap
}

func (m *Player) GetMapUint64UuidUUID() map[uint64]uuid.UUID {
	if m.MapUint64Uuid == nil {
		return nil
	}
	uuids := make(map[uint64]uuid.UUID, len(m.MapUint64Uuid))
	for k, v := range m.MapUint64Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapUint64UuidUUID(u map[uint64]uuid.UUID) {
	if len(u) == 0 {
		m.MapUint64Uuid = nil
		return
	}
	protoMap := make(map[uint64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapUint64Uuid = protoMap
}

func (m *Player) GetMapSint32UuidUUID() map[int32]uuid.UUID {
	if m.MapSint32Uuid == nil {
		return nil
	}
	uuids := make(map[int32]uuid.UUID, len(m.MapSint32Uuid))
	for k, v := range m.MapSint32Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapSint32UuidUUID(u map[int32]uuid.UUID) {
	if len(u) == 0 {
		m.MapSint32Uuid = nil
		return
	}
	protoMap := make(map[int32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapSint32Uuid = protoMap
}

func (m *Player) GetMapSint64UuidUUID() map[int64]uuid.UUID {
	if m.MapSint64Uuid == nil {
		return nil
	}
	uuids := make(map[int64]uuid.UUID, len(m.MapSint64Uuid))
	for k, v := range m.MapSint64Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapSint64UuidUUID(u map[int64]uuid.UUID) {
	if len(u) == 0 {
		m.MapSint64Uuid = nil
		return
	}
	protoMap := make(map[int64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapSint64Uuid = protoMap
}

func (m *Player) GetMapFixed32UuidUUID() map[uint32]uuid.UUID {
	if m.MapFixed32Uuid == nil {
		return nil
	}
	uuids := make(map[uint32]uuid.UUID, len(m.MapFixed32Uuid))
	for k, v := range m.MapFixed32Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapFixed32UuidUUID(u map[uint32]uuid.UUID) {
	if len(u) == 0 {
		m.MapFixed32Uuid = nil
		return
	}
	protoMap := make(map[uint32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapFixed32Uuid = protoMap
}

func (m *Player) GetMapFixed64UuidUUID() map[uint64]uuid.UUID {
	if m.MapFixed64Uuid == nil {
		return nil
	}
	uuids := make(map[uint64]uuid.UUID, len(m.MapFixed64Uuid))
	for k, v := range m.MapFixed64Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapFixed64UuidUUID(u map[uint64]uuid.UUID) {
	if len(u) == 0 {
		m.MapFixed64Uuid = nil
		return
	}
	protoMap := make(map[uint64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapFixed64Uuid = protoMap
}

func (m *Player) GetMapSfixed32UuidUUID() map[int32]uuid.UUID {
	if m.MapSfixed32Uuid == nil {
		return nil
	}
	uuids := make(map[int32]uuid.UUID, len(m.MapSfixed32Uuid))
	for k, v := range m.MapSfixed32Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapSfixed32UuidUUID(u map[int32]uuid.UUID) {
	if len(u) == 0 {
		m.MapSfixed32Uuid = nil
		return
	}
	protoMap := make(map[int32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapSfixed32Uuid = protoMap
}

func (m *Player) GetMapSfixed64UuidUUID() map[int64]uuid.UUID {
	if m.MapSfixed64Uuid == nil {
		return nil
	}
	uuids := make(map[int64]uuid.UUID, len(m.MapSfixed64Uuid))
	for k, v := range m.MapSfixed64Uuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapSfixed64UuidUUID(u map[int64]uuid.UUID) {
	if len(u) == 0 {
		m.MapSfixed64Uuid = nil
		return
	}
	protoMap := make(map[int64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapSfixed64Uuid = protoMap
}

func (m *Player) GetMapBoolUuidUUID() map[bool]uuid.UUID {
	if m.MapBoolUuid == nil {
		return nil
	}
	uuids := make(map[bool]uuid.UUID, len(m.MapBoolUuid))
	for k, v := range m.MapBoolUuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapBoolUuidUUID(u map[bool]uuid.UUID) {
	if len(u) == 0 {
		m.MapBoolUuid = nil
		return
	}
	protoMap := make(map[bool][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapBoolUuid = protoMap
}

func (m *Player) GetMapStringUuidUUID() map[string]uuid.UUID {
	if m.MapStringUuid == nil {
		return nil
	}
	uuids := make(map[string]uuid.UUID, len(m.MapStringUuid))
	for k, v := range m.MapStringUuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapStringUuidUUID(u map[string]uuid.UUID) {
	if len(u) == 0 {
		m.MapStringUuid = nil
		return
	}
	protoMap := make(map[string][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapStringUuid = protoMap
}

func (m *Player) GetMapInt32UUIDs() map[int32]uuid.UUID {
	if m.MapInt32Uuids == nil {
		return nil
	}
	uuids := make(map[int32]uuid.UUID, len(m.MapInt32Uuids))
	for k, v := range m.MapInt32Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapInt32UUIDs(u map[int32]uuid.UUID) {
	if len(u) == 0 {
		m.MapInt32Uuids = nil
		return
	}
	protoMap := make(map[int32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapInt32Uuids = protoMap
}

func (m *Player) GetMapInt64UUIDs() map[int64]uuid.UUID {
	if m.MapInt64Uuids == nil {
		return nil
	}
	uuids := make(map[int64]uuid.UUID, len(m.MapInt64Uuids))
	for k, v := range m.MapInt64Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapInt64UUIDs(u map[int64]uuid.UUID) {
	if len(u) == 0 {
		m.MapInt64Uuids = nil
		return
	}
	protoMap := make(map[int64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapInt64Uuids = protoMap
}

func (m *Player) GetMapUint32UUIDs() map[uint32]uuid.UUID {
	if m.MapUint32Uuids == nil {
		return nil
	}
	uuids := make(map[uint32]uuid.UUID, len(m.MapUint32Uuids))
	for k, v := range m.MapUint32Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapUint32UUIDs(u map[uint32]uuid.UUID) {
	if len(u) == 0 {
		m.MapUint32Uuids = nil
		return
	}
	protoMap := make(map[uint32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapUint32Uuids = protoMap
}

func (m *Player) GetMapUint64UUIDs() map[uint64]uuid.UUID {
	if m.MapUint64Uuids == nil {
		return nil
	}
	uuids := make(map[uint64]uuid.UUID, len(m.MapUint64Uuids))
	for k, v := range m.MapUint64Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapUint64UUIDs(u map[uint64]uuid.UUID) {
	if len(u) == 0 {
		m.MapUint64Uuids = nil
		return
	}
	protoMap := make(map[uint64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapUint64Uuids = protoMap
}

func (m *Player) GetMapSint32UUIDs() map[int32]uuid.UUID {
	if m.MapSint32Uuids == nil {
		return nil
	}
	uuids := make(map[int32]uuid.UUID, len(m.MapSint32Uuids))
	for k, v := range m.MapSint32Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapSint32UUIDs(u map[int32]uuid.UUID) {
	if len(u) == 0 {
		m.MapSint32Uuids = nil
		return
	}
	protoMap := make(map[int32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapSint32Uuids = protoMap
}

func (m *Player) GetMapSint64UUIDs() map[int64]uuid.UUID {
	if m.MapSint64Uuids == nil {
		return nil
	}
	uuids := make(map[int64]uuid.UUID, len(m.MapSint64Uuids))
	for k, v := range m.MapSint64Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapSint64UUIDs(u map[int64]uuid.UUID) {
	if len(u) == 0 {
		m.MapSint64Uuids = nil
		return
	}
	protoMap := make(map[int64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapSint64Uuids = protoMap
}

func (m *Player) GetMapFixed32UUIDs() map[uint32]uuid.UUID {
	if m.MapFixed32Uuids == nil {
		return nil
	}
	uuids := make(map[uint32]uuid.UUID, len(m.MapFixed32Uuids))
	for k, v := range m.MapFixed32Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapFixed32UUIDs(u map[uint32]uuid.UUID) {
	if len(u) == 0 {
		m.MapFixed32Uuids = nil
		return
	}
	protoMap := make(map[uint32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapFixed32Uuids = protoMap
}

func (m *Player) GetMapFixed64UUIDs() map[uint64]uuid.UUID {
	if m.MapFixed64Uuids == nil {
		return nil
	}
	uuids := make(map[uint64]uuid.UUID, len(m.MapFixed64Uuids))
	for k, v := range m.MapFixed64Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapFixed64UUIDs(u map[uint64]uuid.UUID) {
	if len(u) == 0 {
		m.MapFixed64Uuids = nil
		return
	}
	protoMap := make(map[uint64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapFixed64Uuids = protoMap
}

func (m *Player) GetMapSfixed32UUIDs() map[int32]uuid.UUID {
	if m.MapSfixed32Uuids == nil {
		return nil
	}
	uuids := make(map[int32]uuid.UUID, len(m.MapSfixed32Uuids))
	for k, v := range m.MapSfixed32Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapSfixed32UUIDs(u map[int32]uuid.UUID) {
	if len(u) == 0 {
		m.MapSfixed32Uuids = nil
		return
	}
	protoMap := make(map[int32][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapSfixed32Uuids = protoMap
}

func (m *Player) GetMapSfixed64UUIDs() map[int64]uuid.UUID {
	if m.MapSfixed64Uuids == nil {
		return nil
	}
	uuids := make(map[int64]uuid.UUID, len(m.MapSfixed64Uuids))
	for k, v := range m.MapSfixed64Uuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapSfixed64UUIDs(u map[int64]uuid.UUID) {
	if len(u) == 0 {
		m.MapSfixed64Uuids = nil
		return
	}
	protoMap := make(map[int64][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapSfixed64Uuids = protoMap
}

func (m *Player) GetMapBoolUUIDs() map[bool]uuid.UUID {
	if m.MapBoolUuids == nil {
		return nil
	}
	uuids := make(map[bool]uuid.UUID, len(m.MapBoolUuids))
	for k, v := range m.MapBoolUuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapBoolUUIDs(u map[bool]uuid.UUID) {
	if len(u) == 0 {
		m.MapBoolUuids = nil
		return
	}
	protoMap := make(map[bool][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapBoolUuids = protoMap
}

func (m *Player) GetMapStringUUIDs() map[string]uuid.UUID {
	if m.MapStringUuids == nil {
		return nil
	}
	uuids := make(map[string]uuid.UUID, len(m.MapStringUuids))
	for k, v := range m.MapStringUuids {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Player) SetMapStringUUIDs(u map[string]uuid.UUID) {
	if len(u) == 0 {
		m.MapStringUuids = nil
		return
	}
	protoMap := make(map[string][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapStringUuids = protoMap
}

func (m *Child) GetChildUUID() uuid.UUID {
	return uuid.Must(uuid.FromBytes(m.GetChildUuid()))
}

func (m *Child) SetChildUUID(u uuid.UUID) {
	m.ChildUuid = u[:]
}

func (m *Child) GetChildUUIDs() []uuid.UUID {
	uuids := m.GetChildUuids()
	if len(uuids) == 0 {
		return nil
	}
	uuidsSlice := make([]uuid.UUID, len(uuids))
	for i, uid := range uuids {
		if len(uid) != 16 {
			return nil
		}
		uuidsSlice[i] = uuid.Must(uuid.FromBytes(uid))
	}
	return uuidsSlice
}

func (m *Child) SetChildUUIDs(u []uuid.UUID) {
	if len(u) == 0 {
		m.ChildUuids = nil
		return
	}
	uuids := make([][]byte, len(u))
	for i, uid := range u {
		uuids[i] = uid[:]
	}
	m.ChildUuids = uuids
}

func (m *Child) AddChildUUIDs(u ...uuid.UUID) {
	if m.ChildUuids == nil {
		m.ChildUuids = make([][]byte, 0, len(u))
	}
	for _, id := range u {
		m.ChildUuids = append(m.ChildUuids, id[:])
	}
}

func (m *Child) GetMapChildUuidUUID() map[string]uuid.UUID {
	if m.MapChildUuid == nil {
		return nil
	}
	uuids := make(map[string]uuid.UUID, len(m.MapChildUuid))
	for k, v := range m.MapChildUuid {
		if len(v) != 16 {
			return nil
		}
		uuids[k] = uuid.Must(uuid.FromBytes(v))
	}
	return uuids
}

func (m *Child) SetMapChildUuidUUID(u map[string]uuid.UUID) {
	if len(u) == 0 {
		m.MapChildUuid = nil
		return
	}
	protoMap := make(map[string][]byte, len(u))
	for k, uid := range u {
		protoMap[k] = uid[:]
	}
	m.MapChildUuid = protoMap
}
