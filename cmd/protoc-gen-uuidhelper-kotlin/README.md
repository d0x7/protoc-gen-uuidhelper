# protoc-gen-uuidhelper-kotlin Usage

This README explains how to use the Kotlin extensions generated by the `protoc-gen-uuidhelper-kotlin` plugin to read and write your `*_uuid` fields and repeated `*_uuids` in a natural, idiomatic way.

---

## Generated Extensions

For every `bytes foo_uuid = N;` field in your `.proto`, the plugin emits two Kotlin extensions in the same package as your generated classes (e.g. `me.name.app`):

1. **DSL Read/Write property**: `FooUUID: UUID`

2. **Message RO property**: `FooUUID: UUID`

For every `repeated bytes foo_uuids = N;` field in your `.proto`, the plugin emits the same two sets of extensions (with pluralized names for consistency):

1. **DSL getter/setter/adder** on `PlayerKt.Dsl`

    1. Read/Write property: `FooUUIDs: List<UUID>`
    2. Getter: `getFooUUIDs(): List<UUID>` | `getFooUUIDs(index: Int): UUID`
    3. Setter: `setFooUUIDs(value: Collection<UUID>)`
    4. Adder: `addFooUUIDs(vararg values: UUID)` | `addAllFooUUIDs(values: Collection<UUID>)`
    5. Clear: `clearFooUUIDs()`

2. **Message getter** on `Player`

    1. Read-Only property: `FooUUIDs: List<UUID>`
    2. Getter: `getFooUUIDs(): List<UUID>` | `getFooUUIDs(index: Int): UUID`

These extensions and functions wrap the underlying `ByteString` field accessors and convert to/from `UUID` automatically.

> [!NOTE]
> All method names for repeated fields are suffixed with "UUIDs", even when operating on single elements, for consistent naming.

### Example `.proto`

```proto
message Player {
  bytes internal_uuid = 1;
  string username     = 2;
  bytes session_uuid  = 3;
  string string_uuid  = 4;
  repeated bytes game_uuids = 5;
}
```

To see an example of what the plugin generates for the above message, check out this [file](../../internal/test/gen/kotlin/li/xiam/uuidhelper/test/TestUUIDHelperKt.kt) in the `internal/test/gen/kotlin` directory.

---

## Functions

1. **DSL**

   Inside a `player { â€¦ }` block you can assign a `java.util.UUID` directly:

   1. **Single Value**
      
      ```kotlin
      val built = player {
         InternalUUID = UUID.randomUUID()
         SessionUUID = UUID.randomUUID()
      }
      ```      
   
   2. **Repeated Values**

      ```kotlin
      val built = player {
         setGameUUIDs(listOf(UUID.randomUUID(), UUID.randomUUID(), UUID.randomUUID()))
         clearGameUUIDs()
         addGameUUIDs(UUID.randomUUID(), UUID.randomUUID())
         addAllGameUUIDs(listOf(UUID.randomUUID(), UUID.randomUUID(), UUID.randomUUID()))
         getGameUUIDs().forEachIndexed { index, id -> println("UUID #$index is $id") }
         println("First GameUUID is ${getGameUUIDs(0)}")
      }
      ```

   Under the hood, each call converts the `UUID` to a `ByteString` and then sets the field directly, or vice versa.

2. **Accessors**

   After building, you can read the UUIDs using various generated methods on the message:

   ```kotlin
    // Single Value
    println("Internal UUID is $built.InternalUUID")
    println("Session UUID is $built.SessionUUID")
    
    // Repeated Values
    println("There are ${built.GameUUIDs.size} Game UUIDs")
    built.GameUUIDs.forEachIndexed { index, id -> println("UUID #$index is $id") }
    println("First GameUUID is ${built.getGameUUIDs(0)}")
   ```

## Quickstart

1. **Build the plugin**

   ```bash
    go build -o protoc-gen-uuidhelper-kotlin ./cmd/protoc-gen-uuidhelper-kotlin
    ```

    It's recommended to add the plugin to your `$PATH` so you can invoke it directly. To make this easier, there is a Taskfile.yaml, which requires [Task](https://taskfile.dev) to be installed. Then you can do
    
    ```bash
    task install-kotlin
    ```
    
    to install the plugin to your `$PATH`, or use the `install` task to install all available plugins.


2. **Invoke `protoc`**

    If you have the plugin installed in your `$PATH`, you can invoke `protoc` directly:
    
    ```bash
    protoc \
     --uuidhelper-kotlin_out=./gen/kotlin \
     --uuidhelper-kotlin_opt=paths=source_relative \
     your.proto
    ```
    
    This will generate `*UUIDHelperKt.kt` files in `./gen/kotlin` with the respective extensions and functions to set and get UUIDs.

   1. **Plugin options**

      Currently only one option is supported: `threadLocalBuffer` (default: `false`).
      
      This controls whether the plugin uses a thread-local buffer for UUID conversion (useful for performance-sensitive applications).

      To enable it, add this to your `protoc` command:

      ```text
      --uuidhelper-kotlin\_opt=threadLocalBuffer=true
      ```

      The generated code will change slightly:

      ```diff
      +private val bufferPool = ThreadLocal.withInitial { ByteBuffer.allocate(16) }
      +
       // Converts UUID to ByteString (protobuf `bytes`)
       private fun uuidToByteString(uuid: UUID): ByteString {
      -val buffer = ByteBuffer.allocate(16)
      +val buffer = bufferPool.get()
      +buffer.clear()
       buffer.putLong(uuid.mostSignificantBits)
       ```

3. **Import and use in your Kotlin code**

    After importing the generated files, use the new methods to read and write UUIDs as shown above.
